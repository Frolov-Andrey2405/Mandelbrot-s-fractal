"""Constructing the Mandelbrot Fractal"""

import pygame as pg
import numpy as np
from numba import njit, prange
from abc import ABC, abstractmethod
from dataclasses import dataclass
from functools import cached_property

# Settings
RES = WIDTH, HEIGHT = 800, 450
OFFSET = np.array([1.3 * WIDTH, HEIGHT]) // 2
MAX_ITER = 30
ZOOM = 2.2 / HEIGHT

# Texture
texture = pg.image.load("./img/texture/texture.jpg")
TEXTURE_SIZE = min(texture.get_size()) - 1
TEXTURE_ARRAY = pg.surfarray.array3d(texture)


@dataclass
class Color:
    """Dataclass representing a color in RGB format.

    Attributes:
        r (int): The red component of the color.
        g (int): The green component of the color.
        b (int): The blue component of the color.
    """
    r: int
    g: int
    b: int

    def __iter__(self) -> 'Iterator[int]':
        """Return an iterator over the color components.

        Yields:
            int: The red component.
            int: The green component.
            int: The blue component.
        """
        yield self.r
        yield self.g
        yield self.b


class Renderable(ABC):
    """Abstract base class for objects that can be rendered and drawn.

    Subclasses of Renderable must implement the `render` and `draw`
    methods.

    Attributes:
        None

    Methods:
        render(): This method must be implemented by subclasses. It
            is responsible for generating the data that will be used to
            render the object.

        draw(screen): This method must be implemented by subclasses. It
            is responsible for taking the data generated by the `render`
            method and drawing it to a screen.
    """
    @abstractmethod
    def render(self):
        """
        Generate the data needed to render the object
        """
        pass

    @abstractmethod
    def draw(self, screen):
        """
        Draw the object to a screen
        """
        pass


class Fractal(Renderable):
    """
    A Fractal object renders a fractal to a numpy array and can draw it to a screen.

    Args:
        app: An App object that this Fractal is part of.
    """

    def __init__(self, app):
        """
        Initialize a Fractal object
        """
        self.app = app
        self.screen_array = np.full((WIDTH, HEIGHT, 3), [0, 0, 0], dtype=np.uint8)

    @cached_property
    def render_func(self):
        """
        Return a cached property of a numba-compiled function that renders the fractal to a numpy array
        """
        @njit(fastmath=True, parallel=True)
        def render(screen_array):
            """
            Render a fractal to a numpy array
            """
            for x in prange(WIDTH):
                for y in range(HEIGHT):
                    c = (x - OFFSET[0]) * ZOOM + 1j * (y - OFFSET[1]) * ZOOM
                    z = 0j
                    num_iter = 0
                    for _ in range(MAX_ITER):
                        z = z ** 2 + c
                        if z.real ** 2 + z.imag ** 2 > 4:
                            break
                        num_iter += 1
                    col = int(TEXTURE_SIZE * num_iter / MAX_ITER)
                    screen_array[x, y] = TEXTURE_ARRAY[col, col]
            return screen_array
        return render

    def render(self):
        """
        Render the fractal to the screen array
        """
        self.screen_array = self.render_func(self.screen_array)

    def draw(self, screen):
        """
        Draw the fractal to the screen
        """
        pg.surfarray.blit_array(screen, self.screen_array)


class App:
    """
    Main application class that runs the fractal render loop
    """
    def __init__(self):
        """
        Initialize the application with a screen, a clock, and a fractal
        """
        self.screen = pg.display.set_mode(RES, pg.SCALED)
        self.clock = pg.time.Clock()
        self.fractal = Fractal(self)

    def run(self):
        """
        Run the application main loop. Continuously render the fractal
        and draw it to the screen. Quit the application when a QUIT event
        is received
        """
        while True:
            self.screen.fill("black")
            self.fractal.render()
            self.fractal.draw(self.screen)
            pg.display.flip()
            events = pg.event.get()
            quit_events = [event for event in events if event.type == pg.QUIT]
            if quit_events:
                break
            self.clock.tick()
            pg.display.set_caption(f"FPS: {self.clock.get_fps():.2f}")


if __name__ == "__main__":
    app = App()
    app.run()
